Package prolixa;

Helpers	
 letra_min = ['a'..'z'];
 letra_masc = ['A'..'Z'];
 digito = ['0' .. '9'];
 tab = 0x0009;
 any_char = [0 .. 0xffff];
 caracter_especial = [0 .. 0x21] | [0x23 .. 0x26] | 0x27 | [0x28 .. 0x2F] | [0x3A .. 0x40] | [0x5B .. 0x60] | [0x7B .. 0x7E] | [0x80 .. 0xEF];
 caracter_especial_menos_aspas_simples = [0 .. 0x26] | [0x28 .. 0x2F] | [0x3A .. 0x40] | [0x5B .. 0x60] | [0x7B .. 0x7E];
 any_char_menos_chave = [0 .. 0x7C] | [0x7E .. 0xFFFF];
 espaco = ' ';
 ponto = '.';
 rc = 13;
 nl = 10;
 underline = '_';
 single_quote = 39;
 single_bar = 92;
 elementos_acento =  0xC0 | 0xC1 | 0xC2 | 0xC3 | 0xC4 | 0xC5 | 0xC7                                      
  | 0xC8 | 0xC9 | 0xCA | 0xCB                 
  | 0xCC | 0xCD | 0xCE | 0xCF                 
  | 0xD2 | 0xD3 | 0xD4 | 0xD5 | 0xD6          
  | 0xD9 | 0xDA | 0xDB | 0xDC                 
  | 0xE0 | 0xE1 | 0xE2 | 0xE3 | 0xE4 | 0xE5   
  | 0xE7                                      
  | 0xE8 | 0xE9 | 0xEA | 0xEB                 
  | 0xEC | 0xED | 0xEE | 0xEF                 
  | 0xF2 | 0xF3 | 0xF4 | 0xF5 | 0xF6          
  | 0xF9 | 0xFA | 0xFB | 0xFC; 
 
Tokens
 this = 'This';
 is = 'is';
 program = 'program';
 let = 'Let';
 us = 'us';
 begin = 'begin';
 that_maiusculo = 'That';
 would = 'would';
 be = 'be';
 all = 'all';
 it = 'It';
 presents = 'presents';
 alterable = 'alterable';
 unalterable = 'unalterable';
 just = 'just';
 in = 'in';
 case = 'case';
 that_minusculo = 'that';
 as = 'as';
 long = 'long';
 considering = 'considering';
 number = 'number';
 answer = 'answer';
 answer_valores = ('yes' | 'no');
 symbol = 'symbol';
 vazio = (espaco | tab | rc | nl)+;
 identificador = letra_masc (letra_masc | letra_min | underline)*;
 vector = 'vector';
 from = 'from';
 to = 'to';
 by = 'by';
 do = 'do';
 of = 'of';
 otherwise = 'otherwise';
 go = 'go';
 next = 'next';
 iteration = 'iteration';
 capture = 'capture';
 show = 'show';
 abandon = 'abandon';
 abre_parenteses = '(';
 fecha_parenteses = ')';
 abre_colchetes = '[';
 fecha_colchetes = ']';
 abre_chaves = '{';
 fecha_chaves = '}';
 numero = (digito+ | digito+ '.' digito+);
 intermedio_vetor = 'x';
 ponto_virgula = ';';
 virgula = ',';
 string = '"' (letra_masc | letra_min | caracter_especial | digito | elementos_acento)* '"';
 ponto_final = '.';
 dois_pontos = ':';
 comentario = '{' (letra_masc | letra_min | digito | any_char_menos_chave)* '}';
 barra_vertical = '|';
 char = ''' (letra_min | caracter_especial_menos_aspas_simples | elementos_acento | letra_masc | digito | single_bar'n' | single_bar't'| single_bar single_bar | single_bar single_quote) ''';

//operadores
 equal = '==';
 assign = ':=';
 vinculacao = '=';
 not_equal = '!=';
 less_equal = '<=';
 greater_equal = '>=';
 less = '<';
 greater = '>';
 plus = '+';
 minus = '-';
 times = '*';
 divide = '/';
 and = 'and';
 or = 'or';
 xor = 'xor';
 not = '!';
 int_divide = '//';
 
Ignored Tokens
 comentario, vazio;
 
Productions

start {-> programa} = program_prod {-> program_prod.programa};

// definição dos auxiliares
intermedio_vetor_expressoes {-> exp} = intermedio_vetor exp {-> exp};
virgula_expressoes {-> exp} = virgula exp {-> exp};
variaveis_virgula {-> var} = var virgula {-> var};
expressoes_virgula {-> exp} = exp virgula {-> exp};

unalterable_valor {-> exp} = vinculacao valor {-> valor.exp};

this_is_program = this is program;

otherwise_do_geral {-> comando} = otherwise do comando_geral {-> comando_geral.comando};
otherwise_do_loop {-> comando} = otherwise do comando_com_laco {-> comando_com_laco.comando};

// produções
program_prod {-> programa} = this_is_program identificador ponto_final declaracoes? comandos? 
    {-> New programa(identificador, declaracoes.let_us_begin, comandos.it_presents)};

declaracoes {-> let_us_begin} = it presents dois_pontos declaracao+ 
    {-> New let_us_begin([declaracao.declaracao])};

comandos {-> it_presents} = let us begin dois_pontos comando_geral+ that_maiusculo would be all ponto_final 
    {-> New it_presents([comando_geral.comando])};

declaracao {-> declaracao} =
    {variavel} alterable tipo identificador ponto_virgula 
        {-> New declaracao.variavel(tipo.tipo, identificador)}
  | {const} unalterable tipo identificador unalterable_valor? ponto_virgula 
        {-> New declaracao.const(tipo.tipo, identificador, unalterable_valor.exp)}
  | {vetor} vector of tipo abre_parenteses exp intermedio_vetor_expressoes* fecha_parenteses identificador ponto_virgula
        {-> New declaracao.vetor(tipo.tipo, [exp, intermedio_vetor_expressoes.exp], identificador)};
    
tipo {-> tipo} = 
    {number} number {-> New tipo.number()} 
  | {answer} answer {-> New tipo.answer()} 
  | {symbol} symbol {-> New tipo.symbol()};

var {-> var} = 
    {identificador} identificador {-> New var.identificador(identificador)}
  | {identificador_vetor} identificador abre_parenteses exp virgula_expressoes* fecha_parenteses
        {-> New var.identificador_vetor(identificador, [exp, virgula_expressoes.exp])};

unalt {-> identificador} = identificador {-> identificador};

valor {-> exp} =
    {symbol} char {-> New exp.char(char)}
  | {answer} answer_valores {-> New exp.bool(answer_valores)}
  | {numero} numero {-> New exp.numero(numero)}
  | {string} string {-> New exp.string(string)};

just_in_case_completo {-> comando} =
    {just_in_no_otherwise} just in case that_minusculo abre_parenteses exp fecha_parenteses do comando_geral
        {-> New comando.just_in_case(exp, [comando_geral.comando])};

just_in_case_loop {-> comando} =
    just in case that_minusculo abre_parenteses exp fecha_parenteses do comando_com_laco
    {-> New comando.just_in_case(exp, [comando_com_laco.comando])};

comando_base {-> comando} = 
    {atribuicao_var} var assign exp ponto_virgula 
        {-> New comando.atribuicao_var(var.var, exp)}
  | {atribuicao_const} unalt vinculacao exp ponto_virgula 
        {-> New comando.atribuicao_const(unalt.identificador, exp)}
  | {capture} capture abre_parenteses variaveis_virgula* var fecha_parenteses ponto_virgula 
        {-> New comando.capture([variaveis_virgula.var, var.var])}
  | {show} show abre_parenteses expressoes_virgula* exp fecha_parenteses ponto_virgula 
        {-> New comando.show([expressoes_virgula.exp, exp])}
  | {aslongas} as long [as2]:as abre_parenteses exp fecha_parenteses do comando_com_laco 
        {-> New comando.aslongas(exp, [comando_com_laco.comando])}
  | {considering} considering var from exp to [exp2]:exp by [exp3]:exp do comando_com_laco 
        {-> New comando.considering(var.var, exp, exp2, exp3, [comando_com_laco.comando])}
  | {just} just_in_case_completo 
        {-> just_in_case_completo.comando};
	
comando_geral {-> comando} =
    {base} comando_base {-> comando_base.comando}
  | {bloco} bloco {-> bloco.comando};

comando_com_laco {-> comando} =
    {atribuicao_var} var assign exp ponto_virgula 
        {-> New comando.atribuicao_var(var.var, exp)}
  | {atribuicao_const} unalt vinculacao exp ponto_virgula 
        {-> New comando.atribuicao_const(unalt.identificador, exp)}
  | {capture} capture abre_parenteses variaveis_virgula* var fecha_parenteses ponto_virgula 
        {-> New comando.capture([variaveis_virgula.var, var.var])}
  | {show} show abre_parenteses expressoes_virgula* exp fecha_parenteses ponto_virgula 
        {-> New comando.show([expressoes_virgula.exp, exp])}
  | {aslongas} as long [as2]:as abre_parenteses exp fecha_parenteses do comando_com_laco 
        {-> New comando.aslongas(exp, [comando_com_laco.comando])}
  | {considering} considering var from exp to [exp2]:exp by [exp3]:exp do comando_com_laco 
        {-> New comando.considering(var.var, exp, exp2, exp3, [comando_com_laco.comando])}
  | {just} just_in_case_loop 
        {-> just_in_case_loop.comando}
  | {abandon} abandon ponto_virgula 
        {-> New comando.abandon()}
  | {gotonext} go to next iteration ponto_virgula 
        {-> New comando.gotonext()}
  | {bloco} bloco_com_laco 
        {-> bloco_com_laco.comando};

bloco {-> comando} = abre_colchetes declaracao* comando_geral* fecha_colchetes 
    {-> New comando.bloco([declaracao.declaracao], [comando_geral.comando])};

bloco_com_laco {-> comando} = abre_colchetes declaracao* comando_com_laco* fecha_colchetes 
    {-> New comando.bloco([declaracao.declaracao], [comando_com_laco.comando])};

exp {-> exp} =
    [valor]:exp_xor {-> valor.exp};

exp_xor {-> exp} = 
    {xor} [left]:exp_xor xor [right]:exp_or {-> New exp.xor(left.exp, right.exp)}
  | {solo} [valor]:exp_or {-> valor.exp};

exp_or {-> exp} = 
    {or} [left]:exp_or or [right]:exp_and {-> New exp.or(left.exp, right.exp)}
  | {solo} [valor]:exp_and {-> valor.exp};

exp_and {-> exp} = 
    {and} [left]:exp_and and [right]:exp_cmp {-> New exp.and(left.exp, right.exp)}
  | {solo} [valor]:exp_cmp {-> valor.exp};

exp_cmp {-> exp} =
    {igualdade} [left]:exp_cmp equal [right]:exp_termo {-> New exp.equal(left.exp, right.exp)}
  | {desigualdade} [left]:exp_cmp not_equal [right]:exp_termo {-> New exp.not_equal(left.exp, right.exp)}
  | {menor} [left]:exp_cmp less [right]:exp_termo {-> New exp.less(left.exp, right.exp)}
  | {menor_igual} [left]:exp_cmp less_equal [right]:exp_termo {-> New exp.less_equal(left.exp, right.exp)}
  | {maior} [left]:exp_cmp greater [right]:exp_termo {-> New exp.greater(left.exp, right.exp)}
  | {maior_igual} [left]:exp_cmp greater_equal [right]:exp_termo {-> New exp.greater_equal(left.exp, right.exp)}
  | {solo} [valor]:exp_termo {-> valor.exp};

exp_termo {-> exp} =
    {soma} [left]:exp_termo plus [right]:exp_fator {-> New exp.plus(left.exp, right.exp)}
  | {sub} [left]:exp_termo minus [right]:exp_fator {-> New exp.minus(left.exp, right.exp)}
  | {solo} [solo_exp]:exp_fator {-> solo_exp.exp};

exp_fator {-> exp} =
    {mul} [left]:exp_fator times [right]:exp_unario {-> New exp.times(left.exp, right.exp)}
  | {div} [left]:exp_fator divide [right]:exp_unario {-> New exp.divide(left.exp, right.exp)}
  | {div_int} [left]:exp_fator int_divide [right]:exp_unario {-> New exp.int_divide(left.exp, right.exp)}
  | {solo} [solo]:exp_unario {-> solo.exp};

exp_unario {-> exp} =
    {negativo} minus [solo_exp]:exp_unario {-> New exp.minus_exp(solo_exp.exp)}
  | {not} not [solo_exp]:exp_unario {-> New exp.not(solo_exp.exp)}
  | {solo} [pass_exp]:exp_primario {-> pass_exp.exp};

exp_primario {-> exp} =
    {numero} [numero]:numero {-> New exp.numero(numero)}
  | {string} [string]:string {-> New exp.string(string)}
  | {char} [char]:char {-> New exp.char(char)}
  | {bool} [answer]:answer_valores {-> New exp.bool(answer)}
  | {var} [var]:var {-> New exp.var(var.var)}
  | {parenteses} abre_parenteses [subexp]:exp fecha_parenteses {-> subexp};
  
  
Abstract Syntax Tree

programa = identificador [secao_declaracoes]:let_us_begin? [secao_comandos]:it_presents?;

let_us_begin = [declaracoes]:declaracao*;

it_presents = [comandos]:comando*;

declaracao =
    {variavel} [tipo]:tipo identificador
  | {const} [tipo]:tipo identificador [valor]:exp?
  | {vetor} [tipo]:tipo [dimensoes]:exp* identificador;

tipo =
    {number} 
  | {answer} 
  | {symbol};

comando =
    {atribuicao_var} [var]:var [exp]:exp
  | {atribuicao_const} identificador [exp]:exp
  | {capture} [variaveis]:var*
  | {show} [expressoes]:exp*
  | {aslongas} [condicao]:exp [corpo]:comando*
  | {considering} [var]:var [inicio]:exp [fim]:exp [incremento]:exp [corpo]:comando*
  | {just_in_case} [condicao]:exp [corpo]:comando*
  | {abandon}
  | {gotonext}
  | {bloco} [declaracoes]:declaracao* [comandos]:comando*;

exp =
    {xor} [left]:exp [right]:exp
  | {or} [left]:exp [right]:exp
  | {and} [left]:exp [right]:exp
  | {equal} [left]:exp [right]:exp
  | {not_equal} [left]:exp [right]:exp
  | {less} [left]:exp [right]:exp
  | {less_equal} [left]:exp [right]:exp
  | {greater} [left]:exp [right]:exp
  | {greater_equal} [left]:exp [right]:exp
  | {plus} [left]:exp [right]:exp
  | {minus} [left]:exp [right]:exp
  | {times} [left]:exp [right]:exp
  | {divide} [left]:exp [right]:exp
  | {int_divide} [left]:exp [right]:exp
  | {minus_exp} [exp]:exp
  | {not} [exp]:exp
  | {numero} numero
  | {string} string
  | {char} char
  | {var} [var]:var
  | {bool} answer_valores;
  
var =
    {identificador} identificador
  | {identificador_vetor} identificador [indices]:exp*;